x = c(0.9, 1.3, 2.1, 2.5, 2.4, 1.7, 0.7, 1.2, 1.6)
mean(x)
y = c(2.0, 2.6, 4.3, 5.8, 5.1, 3.2, 1.8, 2.3, 3.0)
mean(y)
df = data.frame(x, y)
df
plot(x, y)
res = lm(y~x, df)
res
abline(res)
summary(res)
anova(res)
confint(res, level = 0.95)
corr(x,y)
cor(x,y)
confint(res, level = 0.95)
pf(0.95, 1, 7)
pf(0.05, 1, 7)
pf(0.95, 1, 7)
df(0.95, 1, 7)
qf(0.95, 1, 7)
qf(0.95, 1, 7)
confint(res, level = 0.95)
confint(res, level = 0.90)
confint(res, level = 0.975)
summary(res)
res
pt(0.975, 7)
pt(0.0.025, 7)
pt(0.025, 7)
qt(0.975, 7)
qt(0.025, 7)
confint(res, level = 0.95)  ## confident leven of integer values
anova(res)
qn(0.025)
qnorm(0.025)
qt(0.025, 8)
qt(0.05, 7)
res
res.x
coefficients(res)
coefficients(res)[1]
coefficients(res)[2]
beta_1 = coefficients(res)[2]
beta_1
beta_1[1]
beta_1[1][1]
beta_1 + 1
beta_1*x + coefficients(res)[1]
mean(beta_1*x + coefficients(res)[1])
mean(y - (beta_1*x + coefficients(res)[1]))
x(y - (beta_1*x + coefficients(res)[1]))
x*(y - (beta_1*x + coefficients(res)[1]))
sum(x*(y - (beta_1*x + coefficients(res)[1])))
(beta_1*x + coefficients(res)[1])
sum((beta_1*x + coefficients(res)[1])*(y - (beta_1*x + coefficients(res)[1]))
sum((beta_1*x + coefficients(res)[1])*(y - (beta_1*x + coefficients(res)[1])))
sum((beta_1*x + coefficients(res)[1])*(y - (beta_1*x + coefficients(res)[1])))
(beta_1*x + coefficients(res)[1])*(y - (beta_1*x + coefficients(res)[1]))
sum(y*y)
sum((beta_1*x + coefficients(res)[1])*(beta_1*x + coefficients(res)[1]))
(beta_1*x + coefficients(res)[1])
sum((y - (beta_1*x + coefficients(res)[1]))^2)
sum((y - (beta_1*x + coefficients(res)[1]))^2)
confint(res, level = 0.95)  ## confident leven of integer values
anova(res)
anova(res).ms
anova(res)[1]
anova(res)[3,2]
anova(res)[2,2]
anova(res)[2,3]
anova(res)[2,3]*2
sqrt(anova(res)[2,3])
x - x.mean
x - mean(x)
sum(x - mean(x))
(x - mean(x))^2
sum((x - mean(x))^2)
anova(res)[2,3]/sum((x - mean(x))^2)
sqrt(anova(res)[2,3]/sum((x - mean(x))^2))
2.1626 + 2.365*sqrt(anova(res)[2,3]/sum((x - mean(x))^2))
confint(res, level = 0.95)  ## confident leven of integer values
rm(list = ls(all=T)) # This code clears all.
setwd("F:\teaching\Econometrics\lecture_2023\R_code")
setwd("C:\Users\hollyriver\Documents\Github\Economatrics\Data For Practice\R_code")
setwd("C:\\Users\hollyriver\Documents\Github\Economatrics\Data For Practice\R_code")
setwd("C:\\Users\\hollyriver\Documents\Github\Economatrics\Data For Practice\R_code")
setwd("C:\\Users\\hollyriver\\Documents\Github\Economatrics\Data For Practice\R_code")
setwd("C:\\Users\\hollyriver\\Documents\\Github\Economatrics\Data For Practice\R_code")
setwd("C:\\Users\\hollyriver\\Documents\\Github\\Economatrics\\Data For Practice\R_code")
setwd("C:\\Users\\hollyriver\\Documents\\Github\\Economatrics\\Data For Practice\\R_code")
setwd("C:\\Users\\hollyriver\\Documents\\Github\\Economatrics\\Data For Practice")
seq(from = 10, to = 20, by = 2)
seq(from = 10, to = 20, lengths = 2)
seq(from = 10, to = 20, length = 2)
#Please reset your path for the data
mydata<-read.csv("hprice2.csv", header = TRUE)   ## csv 파일을 데이터프레임으로 불러온다.
mydata
mydata.columns
mydata.column
mydata.col
mydata.index
ls(mydata) #list of variables
head(mydata)  ## 초기 5개 행만 output
# dependent variable
lprice <- mydata$lprice #log(y) variable
lprice
mydata$price
head(mydata$price)
head(mydata$lprice)
#explanatory variables
lnox <- mydata$lnox     #log(nox)
head(mydata$lnox)
ldist <- log(dist)      #log(dist)
dist <- mydata$dist     #distance
ldist <- log(dist)      #log(dist)
ls(mydata)
#plot-----------------------------
dev.new()
plot(lnox, lprice, pch=16, col="blue", cex=1.5)
plot(lnox, lprice, pch=11, col="blue", cex=1.5)  ## 산점도, x, y, 마커 종류, 색상, 사이즈
plot(lnox, lprice, pch=12, col="blue", cex=1.5)  ## 산점도, x, y, 마커 종류, 색상, 사이즈
plot(lnox, lprice, pch=17, col="blue", cex=1.5)  ## 산점도, x, y, 마커 종류, 색상, 사이즈
plot(lnox, lprice, pch=16, col="blue", cex=1.5)  ## 산점도, x, y, 마커 종류, 색상, 사이즈
#plot-----------------------------
dev.new()
plot(lnox, lprice, pch=16, col="blue", cex=1.5)  ## 산점도, x, y, 마커 종류, 색상, 사이즈
X <- cbind(1, lnox, ldist, rooms, stratio)  ## cbind, 자료를 묶음
head(X)
#Stacked data
Y <- lprice
X <- cbind(1, lnox, ldist, rooms, stratio)  ## cbind, 자료를 묶음
rooms <-mydata$rooms
X <- cbind(1, lnox, ldist, rooms, stratio)  ## cbind, 자료를 묶음
stratio <-mydata$stratio  ## student teacher ratio
X <- cbind(1, lnox, ldist, rooms, stratio)  ## cbind, 자료를 묶음
head(X)
head(X)
tail(X)
k<-ncol(X)-1 #number of explanatory variables except for 1
k
n<-length(lprice) #number of home prices
n
#Estimation of the multiple regression model--------------------------------------
tX <- t(X) #transpose X
shape(X)
X.shape
beta.hat <- solve(tX %*% X) %*% tX %*% Y  #solve((tX %*% X)=inverse matrix of (tX %*% X)  ## 행렬곱 : %*%
beta.hat
X.dim
X.dim()
dim(X)
## 실습
mydata = read.csv("C:\\Users\hollyriver\Documents\Github\Economatrics\Data For Practice)
## 실습
mydata = read.csv("C:\\Users\\hollyriver\\Documents\\Github\\Economatrics\\Data For Practice\hprice2.csv")
## 실습
mydata = read.csv("C:\\Users\\hollyriver\\Documents\\Github\\Economatrics\\Data For Practice\\hprice2.csv", header = TRUE)
mydata
ls(mydata)
mydata$stratio
exp(mydata$lnox)
X1 = mydata$dist
X2 = exp(mydata$lnox)
X3 = mydata$rooms
X4 = mydata$stratio
cbind(1, X1, X2, X3, X4)
X1 = mydata$dist
X1 = mydata$dist; dim(X1)
dim(X1)
X1.dim
X1.dim()
ls(mydata)
X1 = mydata$dist
X1
X2 = exp(mydata$lnox)
X2
cbind(1, X1, X2, X3, X4)
#Compute the variances of estimated betas-----------------------------------------
sigma2_hat <- t(Y-X%*%beta.hat)%*%(Y-X%*%beta.hat)/(n-k-1) #5=number of parameters
sigma2_hat #error variance
beta.hat
(Y - solve(t(X)%*%X)%*%t(X)%*%Y)
(Y - solve(t(X) %*% X) %*% t(X)%*%Y)
(Y - (solve(t(X) %*% X) %*% t(X)%*%Y))
## sigma^2_hat = sigma(y-yhat)^2
X
t(X)%*%X
t(X)
t(X)%*%X
dim(t(X)%*%X)
dim(t(X))
dim(X)
solve(t(X)%*%X)
(solve(t(X)%*%X))%*%t(X)
(solve(t(X)%*%X))%*%t(X)%*%Y
(Y - (solve(t(X)%*%X))%*%t(X)%*%Y)
(Y - X(solve(t(X)%*%X))%*%t(X)%*%Y)
(Y - X%*%(solve(t(X)%*%X))%*%t(X)%*%Y)
#Compute the standard errors (se) for betas---------------------------------------
inv_txx=solve(tX%*%X)
var_betas<-as.numeric(sigma2_hat)*inv_txx #variance-covariance matrix  ## type을 바꿈. as.numeric() > matrix를 숫자로
var_betas
#SSR---------------------------------------------------------------------------
U.hat<-Y-X%*%beta.hat
beta_hat = solve(t(X)%*%X))%*%t(X)%*%Y
beta_hat = (solve(t(X)%*%X))%*%t(X)%*%Y)
(Y - X%*%(solve(t(X)%*%X))%*%t(X)%*%Y))
(Y - X%*%(solve(t(X)%*%X))%*%t(X)%*%Y)
beta_hat = (solve(t(X)%*%X))%*%t(X)%*%Y
(Y - X%*%beta_hat)
t(Y - X%*%beta_hat)%*%(Y - X%*%beta_hat)
#Compute the variances of estimated betas-----------------------------------------
sigma2_hat <- t(Y-X%*%beta.hat)%*%(Y-X%*%beta.hat)/(n-k-1) #5=number of parameters
sigma2_hat #error variance
t(Y - X%*%beta_hat)%*%(Y - X%*%beta_hat) / (n-k-1)  ## MSE
#Compute the standard errors (se) for betas---------------------------------------
inv_txx=solve(tX%*%X)  ## covariance를 구하기 위해, sigma*(X'X)^-1
var_betas<-as.numeric(sigma2_hat)*inv_txx #variance-covariance matrix  ## type을 바꿈. as.numeric() > matrix를 숫자로
var_betas
round(var_betas,6)
sigma2_hat #error variance
as.numeric(sigma_hat)*solve(t(X)%*%X)
as.numeric(sigma2_hat)*solve(t(X)%*%X)
var_betas
#SSR---------------------------------------------------------------------------
U.hat<-Y-X%*%beta.hat
SSR<-t(U.hat)%*%U.hat
#SSE---------------------------------------------------------------------------
Y.hat<-X%*%beta.hat  ## yhat - ybar
SSE<-t(Y.hat-mean(Y.hat))%*%(Y.hat-mean(Y.hat))
SSE
#SST---------------------------------------------------------------------------
SST<-t(Y-mean(Y))%*%(Y-mean(Y))
SST
#R-squared
R_squared<-SSE/SST
R_squared
b<-2^3
b
2**3
#####################################
x <- c(1, 3, 4, 8, 9)
x
y<-x+2
y
cbind(x, y)
rbind(x, y)
max(x)
exp(x)
log(x)
length(x)
d2<-seq(from=1, to=10, 1)
d2
d3<-seq(from=10, to=0, -2)
d3
seq(from = 0, to = 9, length = 10)
e<- -3:5
e
j<-2*x+3
j
l<-5:1*x
l
rm(list = ls())
######### [ ] ############
x <- c(1, 3, 4, 8, 9)
a<-x[c(1,4)] #Take the 1st and 4th numbers.
a
b<-x[-c(2,3,5)] # Take the numbers except for the 2th, 3th, and 5th elements.
b
#####################
years <- 2000:2019
years
######################## matrix #############################
A <- matrix(1:6, nrow = 2, byrow=TRUE) #nrow=number of rows
A
t(A) #transpose of A
dim(A)
nrow(A)
#####################
diag(1,4) #4by4
diag(4,4) #4by4
diag(4,2) #2by2
#####################
D5<-rbind(D1, diag(4,2))
D1<-A[1:2, c(1,3)] #extract the numbers corresponding to the 1st and 2nd rows
#####################
D5<-rbind(D1, diag(4,2))
D5
D6<-cbind(D1, diag(4,2))
D6
#####################
#x <- c(1, 3, 4, 8, 9)
names(x) <- c("a", "b", "c", "d", "e")
x
x[1]
x[a]
x.a
x$a
x[a]
x[3]
names
names(1)
names(x)
names(x)
#####################
#x <- c(1, 3, 4, 8, 9)
names(x) <- c("a", "b", "c", "d", "e")
x
names(x)
rownames(D1)<-c("row_1", "row_2")
colnames(D1)<-c("col_1", "col_2")
D1
#####################
rnorm(5) #random draws from the standard normal distribution with mean=0 and sd=1
qnorm(0.95)
pnorm(0)
dnorm(0)
qunif(1)
qunif(0, min = -100, max = 100)
qunif(0.5, min = -100, max = 100)
[]
y <- []
[1,2]
#####################
mylist <-list(sample=rnorm(5),
family="normal distribution",
parameters=list(mean=0, sd=1)
)   ## 리스트에 리스트를 넣은 느낌인데, 딕셔너리는 아닌 것 가틈. 아무거나 막 들어감.
mylist
mylist[]
mylist[]
mylist$sample   ## pandas에서 호출하던 것처럼 하거나, $를 쓰는듯?
mylist[[1]]
mylist[["sample"]]
mylisy[1]
mylist[1]
mylist['sample']
!TRUE
x[which(x>3 & x<=4)] #Since the 3rd satisfies the conditions,
x>3 & x<=4
x[x>3 & x<=4]
x[which(x>3 & x<=4)] #Since the 3rd satisfies the conditions,
which(x>3 & x<=5)
which(x>3 & x<=4)
mean(x)}
mean(x)}
if (rnorm(1)>0){
sum(x)
} else {
mean(x)
}
rm(list = ls(all=T)) # This code clears all. 이런 건 안나옴
setwd("C:\\Users\\hollyriver\\Documents\\Github\\Economatrics\\Data For Practice")  ## set working directory, 작업할 폴더 설정
#Please reset your path for the data
mydata<-read.csv("hprice2.csv", header = TRUE)   ## csv 파일을 데이터프레임으로 불러온다. setwd하지 않았으면 직접위치 지정
ls(mydata) #list of variables, 첫 행 이름의 리스트
colnames(mydata)
which(c(TRUE, FALSE, FALSE, TRUE))
#####################################
x <- c(1, 3, 4, 8, 9)
x[1]
x[which(x>2)]
x[which(x>3)]
typeof(mydata)
typeof(mydata)
mydata.shape
dim(mydata)
mydata
#-----------free style------------
matrix(1:10, ncol = 2)
#-----------free style------------
matrix(c(1:10), ncol = 2)
#-----------free style------------
matrix(list(1:10), ncol = 2)
list(1:10)
#-----------free style------------
matrix((1:10), ncol = 2)
matrix(seq(1, 20, 2), ncol = 3)
matrix(seq(1, 23, 2), ncol = 3)
matrix(seq(1, 17, 2), ncol = 3)
x <- matrix(seq(1, 17, 2), ncol = 3)
solve(x)
x
solve(x)
x <- matrix(seq(7, 23, 2), ncol = 3)
solve(x)
x
x <- matrix(seq(1, 5, length = 9), ncol = 3)
x
solve(x)
x <- matrix(seq(1, 8, length = 9), ncol = 3)
x
solve(x)
x <- matrix(c(1,3,5,6,2,2,3,1,4), ncol = 3)
solve(x)
x
t(x)
rbind(x, t(x))
cbind(x, t(x))
rbind(x, diag(2,3))
colnames(x) <- c('a','b','c')
x
colnames(x) <- c('a','b','c');x
rownames(x) <- c('a','b','c');x
rownames(x) <- c('d','e','f');x
names(x) <- c('a','a','a')
names(x) <- c('a','a','a');x
x
x
rownames(x) <- c('d','e','f');x
colnames(x) <- c('a','b','c');x
rownames(x) <- c('d','e','f');x
list(x)
list(1 = 'a', 2 = 'b', c = 'd')
list(1 <- 'a', 2 = 'b', c = 'd')
list(1 <- 'a', 2 <- 'b', c = 'd')
list(1 <- 'a', 2 <- 'b', c <- 'd')
list(1='a', 2 <- 'b', c <- 'd')
list(a ='1')
list(a = 1, b = 2, 'c' = 3)
lst = list(a = 1, b = 2, 'c' = 3)
lst$a
lst$b
lst$c
lst[['a']]
x
y <- rep(1, 5)
y[-c(1,3)]
y[c(1,3)]
y[1,3]
y[1]
y[1:3]
y[c(1,3)]
print('down')
if (rnorm(1) > 0) {
print('up')
} else {
print('down')
}
if (rnorm(1) > 0) {
print('up')
} else {
print('down')
}
if (rnorm(1) > 0) {
print('up')
} else {
print('down')
}
if (rnorm(1) > 0) {
print('up')
} else {
print('down')
}
if (rnorm(1) > 0) {
print('up')
} else {
print('down')
}
print(i)
while (i > 10) {
i = i + 1
print(i)
}
i = 0
while (i > 10) {
i = i + 1
print(i)
}
while (i < 10) {
i = i + 1
print(i)
}
for (i in c(1:10)) {
print(i)
}
x <- seq(1, 20, 2)
f <- function(x) {
x**2 + 2x + 1
x**2 + 2*x + 1
f <- function(x) {
x**2 + 2*x + 1
}
f(x)
plot(x, f(x))
plot(x, f(x), type = 'l')
plot(x, f(x), type = 'l', color = 'blue')
plot(x, f(x), type = 'l', col = 'blue')
plot(x, f(x), type = 'l', col = 'blue', lwd = 3)
plot(x, f(x), type = 'l', col = 'blue', lwd = 3, main = 'test')
plot(x, f(x), type = 'l', col = 'blue', lwd = 3, main = 'test', pch = 5)
plot(x, f(x), type = 'p', col = 'blue', lwd = 3, main = 'test', pch = 5)
plot(x, f(x), type = 'p', col = 'blue', lwd = 3, main = 'test', pch = 2)
plot(x, f(x), type = 'l', col = 'blue', lwd = 3, main = 'test', pch = 2)
plot(f)
plot(f, type = 'l', col = 'blue', lwd = 3)
f
integrate(f)
integrate(f, lower = 1, upper = 3)
dev.new()
abline(a = 1, b = 3)
abline(a = 1, b = 3)
plot(f)
abline(a = 1, b = 3)
abline(a = 1, b = 3, lwd = 3)
abline(a = 1, b = 3, lwd = 3, color = 'red')
abline(a = 1, b = 3, lwd = 3, col = 'red')
plot(f, col = 'blue')
plot(f, col = 'blue', pch = 3)
plot(f, col = 'blue', lwd = 5)
abline(a = 1, b = 3, lwd = 3, col = 'red')
